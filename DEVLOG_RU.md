# DEVLOG (RU) — состояние проекта MLDSL

Этот файл нужен как “память проекта”: что уже сделано, что болит, как воспроизвести, и куда дальше двигаться.

## Репозитории

- Компилятор/CLI/VS Code расширение: `C:\Users\ASUS\Documents\mlctmodified`
- Мод BetterCode (Forge 1.12.2): `https://github.com/rainbownyashka/mlbettercode`
- Хаб (сайт): `https://github.com/rainbownyashka/mldsl-hub` (Cloudflare Pages + D1)

## Что делали “сегодня” (кратко)

### 1) Инсталлятор/сборка (mlctmodified)

- Пытались собрать “production” дистрибутив:
  - один установщик (setup) + отдельно VS Code расширение `.vsix`;
  - хотели контекстное меню Проводника (ПКМ по `.mldsl`) и “глобальную” команду компилятора в PATH.
- В CI вылезли ошибки:
  - VS Code extension packaging: нет `.vscodeignore` или `files` в `package.json`, нет `LICENSE`, нет `repository` поля;
  - ожидался `dist/payload/mldsl-helper.vsix`, но файл не собран/не лежит там;
  - `tools/build_actions_catalog.py` падал в GitHub Actions из‑за отсутствия `regallactions_export.txt` (на раннере нет `.minecraft`).
- В `packaging/BUILDING.md` начали документировать сборку и зависимости (включая `winget`).

### 2) BetterCode мод (mlbettercode)

- Добавляли UX для экспорта/публикации:
  - Code selector предмет (выделение строк/ивентов), чтобы экспортировать не “весь этаж”, а выбранное.
  - `exportcode` по умолчанию использует выделение (если оно есть).
  - `selectfloor <1..20>` задаёт этаж (Y = N*10-10).
  - `/module publish [name]` собирает “пачку” файлов в `.minecraft/mldsl_publish/<name>_<ts>/` и открывает папку + ссылку на страницу публикации.

### 3) Hub (mldsl-hub)

- Подняли прототип сайта (лента → просмотр поста → лайк/избранное/комменты) с Discord OAuth.
- Подключили D1 (база данных): словили `no such table`, после миграций стало работать.
- Начали приводить UI к более “профессиональному” виду (бейджи рейтинга, иконки, фуллскрин просмотр, правки текста про автомодерацию).

### 4) AI‑агент (mlctmodified/tools/_premium)

Цель: сделать “кодера” для MLDSL, который:
1) НЕ галлюцинирует несуществующие действия/аргументы/enum’ы,
2) стабильно пишет валидный код (или IR) и проходит `check_compilation`,
3) работает с локальными моделями.

Проблемы, которые ловили:
- модели часто “забывают” формат tool-calls и пишут псевдокод;
- Ollama модели иногда “умирают” на tool-calls (400 “does not support tools”) либо зависают в стриме;
- без строгой схемы модель угадывает аргументы и ошибается.

Улучшения, которые внедряли:
- builder‑tools в `tools/_premium/ai_coder.py`: закрытие блоков без ID (закрыть “верхний” блок нужного типа), чтобы модель не ломалась на неверных id.
- `check_compilation` расширен: принимает `path` или `file_id`.
- добавлены новые prompt‑файлы UTF‑8 для smoke‑тестов builder режима.

## Что осталось (план на ближайшее)

### A) Закрыть CI/релизы компилятора + VSIX

1) VS Code extension:
   - добавить `.vscodeignore` (или `files` в `package.json`);
   - добавить `LICENSE` и `repository` в `package.json`;
   - гарантировать сборку `mldsl-helper.vsix` и копирование в `dist/payload/`.
2) `build_actions_catalog.py`:
   - CI не должен зависеть от `C:\Users\runneradmin\AppData\Roaming\.minecraft\regallactions_export.txt`;
   - вариант: хранить “seed export” в репо (например, `seed/regallactions_export.txt`) и использовать его по умолчанию в CI;
   - если seed отсутствует — падать с явной ошибкой (никаких “тихих” пропусков).

### B) Хаб: UX/страницы

- Профиль (страница пользователя): посты, суммарные лайки, репутация, настройки.
- Фуллскрин просмотр поста/ленты, ESC закрывает просмотр.
- Оптимизация: пагинация/сортировка по рейтингу, лимиты размера файлов (например 0.4–1 МБ), валидация расширений `.mldsl`.

### C) AI‑подпроект: “новые подходы” (самое важное)

Главная ставка, чтобы локальные модели перестали тупить:

1) **IR + валидатор + компилятор tool‑calls**
   - модель выдаёт только JSON‑IR (строго по схеме),
   - валидатор проверяет соответствие `get_sig`/enum/аргументам,
   - детерминированный компилятор генерирует tool‑calls/MLDSL.
   - Это убирает 90% галлюцинаций.

2) **Grammar‑constrained decoding** (если будем встраивать в llama.cpp/Outlines)
   - модель физически не может вывести невалидный токен (вне списка действий/ключей/enum’ов).

3) DSPy / “само‑оптимизация” промптов
   - полезно, но только после того как появится стабильно проверяемый IR.

## Как продолжать после сброса контекста

1) Для сборки/CI: начать с исправления VSIX packaging (см. A).
2) Для AI: сначала стабилизировать протокол tool‑calls/IR (см. C.1), потом снова сравнивать модели.
3) Для Hub: доделать профиль + пагинацию + лимиты/валидацию файлов (см. B).

